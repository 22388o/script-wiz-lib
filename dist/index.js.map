{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/./src/convertion/index.ts","webpack://[name]/./src/utils/index.ts","webpack://[name]/./src/convertion/hex.ts","webpack://[name]/./src/opcodes/BITCOIN_SEGWIT.ts","webpack://[name]/./src/convertion/const/index.ts","webpack://[name]/./src/convertion/bytes.ts","webpack://[name]/./src/convertion/number.ts","webpack://[name]/./src/opcodes/model/VM.ts","webpack://[name]/./src/opcodes/BITCOIN_TAPSCRIPT.ts","webpack://[name]/./src/opcodes/LIQUID_SEGWIT.ts","webpack://[name]/./src/scriptWiz/compileAll.ts","webpack://[name]/./src/index.ts","webpack://[name]/./src/convertion/model/WizData.ts","webpack://[name]/./src/convertion/bin.ts","webpack://[name]/./src/convertion/string.ts","webpack://[name]/./src/scriptWiz/index.ts","webpack://[name]/./src/opcodes/index.ts","webpack://[name]/./src/opcodes/common.ts","webpack://[name]/./src/opcodes/LIQUID_TAPSCRIPT.ts","webpack://[name]/./src/scriptWiz/parse.ts","webpack://[name]/./src/scriptWiz/opFuncs.ts","webpack://[name]/./src/core/arithmetics.ts","webpack://[name]/./src/scriptWiz/parseFinalInput.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","MAX_INTEGER","WizData","hexLittleEndian","hex","length","str","j","startsWith","substring","console","warn","flipbits","split","map","b","toString","join","cropTwo","opWordToHex","word","opWordCodes","find","owc","opcodeToWord","opcode","currentScope","wizDataList","flow","EMOJI_REGEX","hexFixBytes","padStart","Math","ceil","validHex","test","hexLE","bytesToHex","hexToBytes","reverse","Uint8Array","from","matches","match","hexToHexBytes","byte","parseInt","hexToByte","hexBoundaries","bytesLength","b1","pow","b2","minPos","maxPos","minNeg","maxNeg","opcodesBitcoinSegwit","commonOpcodes","bytes","reduce","hexString","currentByte","validByte","byteToHex","bytesToString","out","pos","c1","String","fromCharCode","c2","u","c3","bytesToNumber","numberIsValid","boundaries","undefined","numberHex","bytesToBin","bin","log","base","x","numeralNextValue","numeral","nextValue","numberToBytes","byteLength","floor","uint8Array","resizedUint8Array","maxNumber","fill","set","resizeBytes","baseNumber","lastValue","numeralArray","push","uint8NumberToBytes","VM_NETWORK","VM_NETWORK_VERSION","opcodesBitcoinTapscript","opcodesLiquidSegwit","description","toLEPadByte","number","padHex","compileData","compileJoin","hexes","lib","text","inputVal","outputVal","bytesVal","binVal","hexVal","numberVal","textVal","binToBytes","stringToBytes","this","input","output","fromHex","fromBin","fromNumber","fromText","binFixBytes","validBin","binToBinBytes","binByte","binToByte","charCodeAt","initialStackDataList","inputHexes","main","alt","altFlow","isStackFailed","BTC","SEGWIT","stackDataList","init","version","Opcodes","data","parseInput","currentScopeParse","currentScopeParseException","parseResult","parse","inputHex","errorMessage","removeLastSize","slice","removeLastStackData","concat","addDataArray","addData","compileScript","clearStack","vm","wordData","wordCode","code","wordHex","codeData","codeWord","network","ver","opcodesLiquidTapscript","opcodes","emptyParseResultData","endsWith","finalInput","substr","addStackData","parseFinalInput","isNaN","Number","opFuncs","ex","opCodes","mainStackDataArray","mainStackDataArrayLength","currentOpCode","oc","arithmetics","add1","sub1","negate","abs","not","notEqual0","add","sub","mul","div","lshift","rshift","boolAnd","boolOr","numEqual","numEqualVerify","numNotEqual","lessThan","graterThan","lessThanOrEqual","graterThanOrEqual","min","max","withIn","wizData","numberValue","negateValue","absValue","isfalse","wizData2","addedValue","subValue","mulValue","divValue","lShiftValue","rShiftValue","equal","wizData3","currentNumber","minValue","maxValue","cropedInput","formattedInput"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n","import { MAX_INTEGER } from \"./const\";\r\nimport { WizData } from \"./model/WizData\";\r\n\r\nexport default WizData;\r\nexport { MAX_INTEGER };\r\n","import { WizDataList } from \"../model\";\r\nimport { Opcodes } from \"../opcodes\";\r\nimport { Opcode } from \"../opcodes/model/Opcode\";\r\nimport { VM } from \"../opcodes/model/VM\";\r\n\r\nexport const hexLittleEndian = (hex: string): string => {\r\n  if (hex.length % 2 === 0) {\r\n    let str = \"0x\";\r\n    let j = 0;\r\n\r\n    if (hex.startsWith(\"0x\")) {\r\n      j = 2;\r\n    }\r\n\r\n    for (let i = hex.length; i > j; i -= 2) {\r\n      str += hex.substring(i - 2, i);\r\n    }\r\n\r\n    return str;\r\n  } else {\r\n    console.warn(\"its odd\");\r\n    return \"something went wrong\";\r\n  }\r\n};\r\n\r\nexport const flipbits = (str: string): string => {\r\n  return str\r\n    .split(\"\")\r\n    .map((b: any) => (1 - b).toString())\r\n    .join(\"\");\r\n};\r\n\r\nexport const cropTwo = (hex: string): string => hex.substring(2);\r\n\r\nexport const opWordToHex = (word: string, opWordCodes: Opcode[]): string => {\r\n  const hex = opWordCodes.find((owc) => owc.word === word)?.hex;\r\n  return hex || \"\";\r\n};\r\n\r\n// export const opWordToCode = (word: string, vm: VM): number => {\r\n//   const opCodes = new Opcodes(vm);\r\n\r\n//   const opcode = opCodes.data.find((owc) => owc.word === word)?.opcode;\r\n//   return opcode === undefined ? -1 : opcode;\r\n// };\r\n\r\nexport const opcodeToWord = (opcode: number, opWordCodes: Opcode[]): string => {\r\n  return opWordCodes.find((owc) => owc.opcode === opcode)?.word || \"\";\r\n};\r\n\r\n// supports all opcodes\r\nexport const currentScope = (wizDataList: WizDataList): boolean => wizDataList.flow[wizDataList.flow.length - 1];\r\nexport const EMOJI_REGEX = /([\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2694-\\u2697]|\\uD83E[\\uDD10-\\uDD5D])/g;\r\n","import { bytesToHex } from \"./bytes\";\r\n\r\nexport const hexFixBytes = (hex: string) => (hex.length % 2 === 0 ? hex : hex.padStart(Math.ceil(hex.length / 2) * 2, \"0\"));\r\n\r\nconst validHex = (hex: string) => hex.length % 2 === 0 && !/[^a-fA-F0-9]/u.test(hex);\r\n\r\nexport const hexLE = (hex: string): string => bytesToHex(hexToBytes(hex).reverse());\r\n\r\nconst hexToHexBytes = (hex: string): string[] => {\r\n  if (!validHex(hex)) throw \"hexToHexBytes: invalid hex string\";\r\n  const matches: RegExpMatchArray | null = hex.match(/.{1,2}/g);\r\n  if (matches === null) return [];\r\n  return matches.map((match: string) => match);\r\n};\r\n\r\nconst hexToByte = (hex: string): number => {\r\n  if (!validHex(hex)) throw \"hexToByte: invalid hex string\";\r\n  return parseInt(hex, 16);\r\n};\r\n\r\nexport const hexToBytes = (hex: string): Uint8Array => Uint8Array.from(hexToHexBytes(hex).map((byte) => hexToByte(byte)));\r\n\r\n// const hexToString = (hex: string): string => bytesToString(hexToBytes(hex));\r\n\r\ninterface NumberBoundries {\r\n  minPos: number;\r\n  maxPos: number;\r\n  minNeg: number;\r\n  maxNeg: number;\r\n}\r\n\r\nexport const hexBoundaries = (bytesLength: number): NumberBoundries | undefined => {\r\n  // 2^(8n-9) <= x <= 2^(8n-1) - 1\r\n  // -2(8n-9) >= x >= -2^(8n-1) + 1\r\n\r\n  const b1 = Math.pow(2, 8 * bytesLength - 9);\r\n  const b2 = Math.pow(2, 8 * bytesLength - 1);\r\n\r\n  if (0 < bytesLength && bytesLength < 5) {\r\n    return {\r\n      minPos: b1,\r\n      maxPos: b2 - 1,\r\n      minNeg: 1 - b2,\r\n      maxNeg: -1 * b1,\r\n    };\r\n  }\r\n\r\n  return;\r\n};\r\n","import { Opcode } from \"./model/Opcode\";\r\nimport { commonOpcodes } from \"./common\";\r\n\r\nexport const opcodesBitcoinSegwit: Opcode[] = [...commonOpcodes];\r\n","export const MAX_INTEGER = 2147483647;\r\n","import { hexBoundaries, hexLE } from \"./hex\";\r\nimport { numberIsValid } from \"./number\";\r\n\r\nconst validByte = (byte: number): boolean => 0 <= byte || byte <= 255;\r\n\r\n// const bytesLE = (bytes: Uint8Array): Uint8Array => bytes.reverse();\r\n\r\nconst byteToHex = (byte: number): string => {\r\n  if (!validByte(byte)) throw \"byteToHex: invalid byte number\";\r\n  return byte.toString(16).padStart(2, \"0\");\r\n};\r\n\r\nexport const bytesToHex = (bytes: Uint8Array): string => bytes.reduce((hexString, currentByte) => hexString + byteToHex(currentByte), \"\");\r\n\r\n/**\r\n * This implementations is derived from:\r\n * https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js\r\n *\r\n * Copyright 2008 The Closure Library Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nexport const bytesToString = (bytes: Uint8Array): string => {\r\n  const out: string[] = [];\r\n  let pos: number = 0,\r\n    c: number = 0;\r\n  while (pos < bytes.length) {\r\n    const c1: number = bytes[pos++];\r\n    if (c1 < 128) {\r\n      out[c++] = String.fromCharCode(c1);\r\n    } else if (c1 > 191 && c1 < 224) {\r\n      const c2: number = bytes[pos++];\r\n      out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\r\n    } else if (c1 > 239 && c1 < 365) {\r\n      // Surrogate Pair\r\n      const c2: number = bytes[pos++];\r\n      const c3: number = bytes[pos++];\r\n      const c4: number = bytes[pos++];\r\n      const u: number = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) - 0x10000;\r\n      out[c++] = String.fromCharCode(0xd800 + (u >> 10));\r\n      out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\r\n    } else {\r\n      const c2: number = bytes[pos++];\r\n      const c3: number = bytes[pos++];\r\n      out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\r\n    }\r\n  }\r\n  return out.join(\"\");\r\n};\r\n\r\nexport const bytesToNumber = (bytes: Uint8Array): number | undefined => {\r\n  if (bytes.length == 0) return 0;\r\n  if (4 < bytes.length) return;\r\n\r\n  const hex = bytesToHex(bytes);\r\n  if (!numberIsValid(hex, bytes.length)) return;\r\n\r\n  const boundaries = hexBoundaries(bytes.length);\r\n  if (boundaries === undefined) return;\r\n\r\n  const numberHex: number = parseInt(hexLE(hex), 16);\r\n  if ((boundaries.minPos <= numberHex && numberHex <= boundaries.maxPos) || numberHex === 0) return numberHex;\r\n\r\n  // if (boundaries.minNeg <= numberHex && numberHex <= boundaries.maxNeg)\r\n  return Math.pow(2, 8 * bytes.length - 1) - numberHex;\r\n};\r\n\r\nexport const bytesToBin = (bytes: Uint8Array): string => bytes.reduce((bin, byte) => byte.toString(2).padStart(8, \"0\") + bin, \"\");\r\n","import { hexLE } from \"./hex\";\r\n\r\nconst BIT_8 = 8;\r\nconst BIT_16 = 16;\r\nconst BIT_32 = 32;\r\n\r\nconst log = (base: number, x: number): number => Math.log(x) / Math.log(base);\r\n\r\nconst numberByteLength = (x: number): number => {\r\n  if (x === 0) return 0;\r\n  else if (0 < x) return Math.ceil((log(2, x + 1) + 1) / 8);\r\n  else if (x < 0) return Math.floor((log(2, -x) + 1) / 8 + 1);\r\n  return 0;\r\n};\r\n\r\nconst resizeBytes = (uint8Array: Uint8Array, byteLength: number): Uint8Array => {\r\n  const resizedUint8Array: Uint8Array = new Uint8Array(byteLength);\r\n  if (uint8Array.length > byteLength) {\r\n    const maxNumber: number = Math.pow(2, BIT_8) - 1;\r\n    resizedUint8Array.fill(maxNumber);\r\n  } else {\r\n    resizedUint8Array.set(uint8Array);\r\n  }\r\n  return resizedUint8Array;\r\n};\r\n\r\nconst numeralNextValue = (value: number, base: number): { numeral: number; nextValue: number } => {\r\n  const numeral: number = value % base;\r\n  const nextValue: number = (value - numeral) / base;\r\n  return { numeral, nextValue };\r\n};\r\n\r\nconst uint8NumberToBytes = (value: number): Uint8Array => {\r\n  const baseNumber: number = Math.pow(2, BIT_8);\r\n  let lastValue: number = value;\r\n  const numeralArray: number[] = [];\r\n\r\n  while (lastValue >= baseNumber) {\r\n    const { numeral, nextValue } = numeralNextValue(lastValue, baseNumber);\r\n    numeralArray.push(numeral);\r\n    lastValue = nextValue;\r\n  }\r\n\r\n  if (lastValue > 0) numeralArray.push(lastValue);\r\n  const result: Uint8Array = Uint8Array.from(numeralArray);\r\n  return result;\r\n};\r\n\r\nexport const numberToBytes = (value: number): Uint8Array => {\r\n  const byteLength: number = numberByteLength(value);\r\n  const inputNumber: number = value < 0 ? Math.pow(2, 8 * byteLength - 1) - value : value;\r\n  const uint8NumberBytes: Uint8Array = uint8NumberToBytes(inputNumber);\r\n  return resizeBytes(uint8NumberBytes, byteLength);\r\n};\r\n\r\nexport const numberIsValid = (hex: string, byteLength: number): boolean => {\r\n  const numberHex: number = parseInt(hexLE(hex), 16);\r\n\r\n  // 1 byte\r\n  // n = 0x00\r\n  // n = 0x80\r\n  if (byteLength === 1) if (0x00 == numberHex || 0x80 == numberHex) return false;\r\n\r\n  // 2 byte\r\n  // 0x0001 <= n <= 0x007f\r\n  // 0x8000 <= n <= 0x807f\r\n  if (byteLength === 2) if ((0x0001 <= numberHex && numberHex <= 0x007f) || (0x8000 <= numberHex && numberHex <= 0x807f)) return false;\r\n\r\n  // 3 byte\r\n  // 0x000001 <= n <= 0x007fff\r\n  // 0x800000 <= n <= 0x807fff\r\n  if (byteLength === 3) if ((0x000001 <= numberHex && numberHex <= 0x007fff) || (0x800000 <= numberHex && numberHex <= 0x807fff)) return false;\r\n\r\n  // 4 byte\r\n  // 0x00000001 <= n <= 0x007fffff\r\n  // 0x80000000 <= n <= 0x807fffff\r\n  if (byteLength === 4) if ((0x00000001 <= numberHex && numberHex <= 0x007fffff) || (0x80000000 <= numberHex && numberHex <= 0x807fffff)) return false;\r\n\r\n  return true;\r\n};\r\n","export enum VM_NETWORK {\r\n  BTC = \"BTC\",\r\n  LIQUID = \"LIQUID\",\r\n}\r\n\r\nexport enum VM_NETWORK_VERSION {\r\n  SEGWIT = \"00\",\r\n  TAPSCRIPT = \"01\",\r\n}\r\n\r\nexport interface VM {\r\n  network: VM_NETWORK;\r\n  ver: VM_NETWORK_VERSION;\r\n}\r\n","import { Opcode } from \"./model/Opcode\";\r\nimport { opcodesBitcoinSegwit } from \"./BITCOIN_SEGWIT\";\r\n\r\nexport const opcodesBitcoinTapscript: Opcode[] = [...opcodesBitcoinSegwit];\r\n","import { Opcode } from \"./model/Opcode\";\r\nimport { opcodesBitcoinSegwit } from \"./BITCOIN_SEGWIT\";\r\n\r\nexport const opcodesLiquidSegwit: Opcode[] = [\r\n  ...opcodesBitcoinSegwit,\r\n\r\n  /*\r\n   * Constants\r\n   * * 0 - 96\r\n   */\r\n\r\n  /*\r\n   * Flow control\r\n   * * 97 - 106\r\n   */\r\n\r\n  /*\r\n   * Stack\r\n   * * 107 - 125\r\n   */\r\n\r\n  /*\r\n   * Splice\r\n   * 126 - 130\r\n   */\r\n  { word: \"OP_CAT\", opcode: 126, hex: \"0x7e\", description: \"Concatenates two strings.\" }, //\tx1 x2\tout\tConcatenates two strings. disabled.\r\n  { word: \"OP_SUBSTR\", opcode: 127, hex: \"0x7f\", description: \"Returns a section of a string.\" }, //\tin begin size\tout\tReturns a section of a string. disabled.\r\n  { word: \"OP_LEFT\", opcode: 128, hex: \"0x80\", description: \"Keeps only characters left of the specified point in a string.\" }, //\tin size\tout\tKeeps only characters left of the specified point in a string. disabled.\r\n  { word: \"OP_RIGHT\", opcode: 129, hex: \"0x81\", description: \"Keeps only characters right of the specified point in a string\" }, //\tin size\tout\tKeeps only characters right of the specified point in a string. disabled.\r\n\r\n  /*\r\n   * Bitwise logic\r\n   * 131 - 136\r\n   */\r\n  { word: \"OP_INVERT\", opcode: 131, hex: \"0x83\", description: \"Flips all of the bits in the input.\" }, //\tin\tout\tFlips all of the bits in the input. disabled.\r\n  { word: \"OP_AND\", opcode: 132, hex: \"0x84\", description: \"Boolean and between each bit in the inputs.\" }, //\tx1 x2\tout\tBoolean and between each bit in the inputs. disabled.\r\n  { word: \"OP_OR\", opcode: 133, hex: \"0x85\", description: \"Boolean or between each bit in the inputs.\" }, //\tx1 x2\tout\tBoolean or between each bit in the inputs. disabled.\r\n  { word: \"OP_XOR\", opcode: 134, hex: \"0x86\", description: \"Boolean exclusive or between each bit in the inputs.\" }, //\tx1 x2\tout\tBoolean exclusive or between each bit in the inputs. disabled.\r\n\r\n  /*\r\n   * Arithmetic\r\n   * 139 - 165\r\n   */\r\n  { word: \"OP_LSHIFT\", opcode: 152, hex: \"0x98\", description: \"Shifts a left b bits, preserving sign.\" }, //\ta b\tout\tShifts a left b bits, preserving sign. disabled.\r\n  { word: \"OP_RSHIFT\", opcode: 153, hex: \"0x99\", description: \"Shifts a right b bits, preserving sign.\" }, //\ta b\tout\tShifts a right b bits, preserving sign. disabled.\r\n\r\n  /*\r\n   * Crypto\r\n   * 166 - 175\r\n   */\r\n\r\n  /*\r\n   * Locktime\r\n   * 177 - 178\r\n   */\r\n\r\n  /*\r\n   * Reserved words\r\n   * 80, 98, 101, 102, 137, 138, 176, 179-185\r\n   */\r\n\r\n  /*\r\n   * Liquid words\r\n   * 193, 194, 195\r\n   */\r\n  {\r\n    word: \"OP_CHECKSIGFROMSTACK\",\r\n    opcode: 193,\r\n    hex: \"0xc1\",\r\n    description:\r\n      \"Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a Script Number 1, otherwise push a Script Number 0.\",\r\n  },\r\n  {\r\n    word: \"OP_CHECKSIGFROMSTACKVERIFY\",\r\n    opcode: 194,\r\n    hex: \"0xc2\",\r\n    description:\r\n      \"Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a Script Number 1, otherwise push a Script Number 0.\",\r\n  },\r\n  { word: \"OP_SUBSTR_LAZY\", opcode: 195, hex: \"0xc3\", description: \"Returns a section of a string.\" }, //\tliquid network feature.\r\n\r\n  /*\r\n   * Pseudo-words\r\n   * 253 - 255\r\n   */\r\n];\r\n","import { cropTwo, hexLittleEndian } from \"../utils\";\r\n\r\nconst toLEPadByte = (number: number) => {\r\n  const hex = number.toString(16);\r\n  const padHex = hex.length % 2 === 0 ? hex : \"0\" + hex;\r\n  return cropTwo(hexLittleEndian(padHex));\r\n};\r\n\r\nexport const compileData = (hex: string): string => {\r\n  const byteLength = hex.length / 2;\r\n\r\n  // 0byte\r\n  if (byteLength === 0) {\r\n    return \"00\";\r\n  }\r\n\r\n  // 1 byte\r\n  else if (byteLength === 1) {\r\n    const n = parseInt(hex, 16);\r\n    if (0 < n && n < 17) {\r\n      return (n + 80).toString(16);\r\n    } else {\r\n      return \"01\" + cropTwo(hex);\r\n    }\r\n  }\r\n\r\n  // 1 < byte <= 75\r\n  else if (1 < byteLength && byteLength <= 75) {\r\n    return toLEPadByte(byteLength) + cropTwo(hex);\r\n  }\r\n\r\n  // 76 < byte <= 255\r\n  else if (76 < byteLength && byteLength <= 255) {\r\n    return \"4c\" + toLEPadByte(byteLength) + cropTwo(hex);\r\n  }\r\n\r\n  // 256 < byte <= 520\r\n  else if (256 < byteLength && byteLength <= 520) {\r\n    return \"4d\" + toLEPadByte(byteLength) + cropTwo(hex);\r\n  }\r\n\r\n  // 520 < byte\r\n  else {\r\n    throw \"compileAll: Push exceeds the push size limit of 520 bytes.\";\r\n  }\r\n};\r\n\r\nexport const compileJoin = (hexes: string[]): string => \"0x\" + hexes.join(\"\");\r\n","import WizData from \"./convertion\";\r\nimport { WizDataList } from \"./model\";\r\nimport * as lib from \"./scriptWiz\";\r\n\r\nexport { lib, WizData, WizDataList };\r\n","import { MAX_INTEGER } from \"../const\";\r\nimport { binToBytes } from \"../bin\";\r\nimport { bytesToBin, bytesToHex, bytesToNumber } from \"../bytes\";\r\nimport { hexToBytes } from \"../hex\";\r\nimport { numberToBytes } from \"../number\";\r\nimport { stringToBytes } from \"../string\";\r\n\r\nexport class WizData {\r\n  input: string | number;\r\n  output: string | number;\r\n\r\n  bytes: Uint8Array;\r\n  bin: string;\r\n  hex: string;\r\n\r\n  number?: number;\r\n  text?: string;\r\n\r\n  private constructor(hex?: string, bin?: string, number?: number, text?: string) {\r\n    let inputVal: string | number = \"\";\r\n    let outputVal: string | number = \"\";\r\n\r\n    let bytesVal: Uint8Array = new Uint8Array([]);\r\n    let binVal: string = \"\";\r\n    let hexVal: string = \"\";\r\n\r\n    let numberVal: number | undefined = undefined;\r\n    let textVal: string | undefined = undefined;\r\n\r\n    // fromHex\r\n    if (hex !== undefined) {\r\n      inputVal = hex;\r\n      bytesVal = hexToBytes(hex);\r\n      binVal = bytesToBin(bytesVal);\r\n      hexVal = hex;\r\n      numberVal = bytesToNumber(bytesVal);\r\n      // textVal = bytesToString(bytesVal); // TODO get from stack cache\r\n    }\r\n\r\n    // fromBin\r\n    else if (bin !== undefined) {\r\n      inputVal = bin;\r\n      bytesVal = binToBytes(bin);\r\n      binVal = bin;\r\n      hexVal = bytesToHex(bytesVal);\r\n      numberVal = bytesToNumber(bytesVal);\r\n      // textVal = bytesToString(bytesVal); // TODO get from stack cache\r\n    }\r\n\r\n    // fromNumber\r\n    else if (number !== undefined) {\r\n      inputVal = number;\r\n      bytesVal = numberToBytes(number);\r\n      binVal = bytesToBin(bytesVal);\r\n      hexVal = bytesToHex(bytesVal);\r\n      numberVal = number;\r\n      // textVal = bytesToString(bytesVal); // TODO get from stack cache\r\n    }\r\n\r\n    // fromText\r\n    else if (text !== undefined) {\r\n      inputVal = text;\r\n      bytesVal = stringToBytes(text);\r\n      binVal = bytesToBin(bytesVal);\r\n      hexVal = bytesToHex(bytesVal);\r\n      numberVal = bytesToNumber(bytesVal);\r\n      textVal = text; // TODO set to stack cache\r\n    }\r\n\r\n    // set props\r\n    this.input = inputVal;\r\n    this.bytes = bytesVal;\r\n    this.bin = binVal;\r\n    this.hex = hexVal;\r\n    if (numberVal !== undefined && -MAX_INTEGER <= numberVal && numberVal <= MAX_INTEGER) this.number = numberVal;\r\n    this.text = textVal;\r\n\r\n    if (this.text !== undefined) outputVal = this.text;\r\n    else if (this.number !== undefined) outputVal = this.number;\r\n    else outputVal = this.hex;\r\n    this.output = outputVal;\r\n  }\r\n\r\n  public static fromHex(hex: string): WizData {\r\n    return new WizData(hex, undefined, undefined, undefined);\r\n  }\r\n\r\n  public static fromBin(bin: string): WizData {\r\n    return new WizData(undefined, bin, undefined, undefined);\r\n  }\r\n\r\n  public static fromNumber(number: number): WizData {\r\n    return new WizData(undefined, undefined, number, undefined);\r\n  }\r\n\r\n  public static fromText(text: string): WizData {\r\n    return new WizData(undefined, undefined, undefined, text);\r\n  }\r\n}\r\n","export const binFixBytes = (bin: string): string => (bin.length % 8 === 0 ? bin : bin.padStart(Math.ceil(bin.length / 8) * 8, \"0\"));\r\n\r\nconst validBin = (bin: string): boolean => !/[^01]/u.test(bin) && bin.length % 8 === 0;\r\n\r\nconst binToBinBytes = (bin: string): string[] => {\r\n  if (!validBin(bin)) throw \"binToBinBytes: invalid bin string\";\r\n  const matches: RegExpMatchArray | null = bin.match(/.{1,8}/g);\r\n  if (matches === null) return [];\r\n  return matches.map((match: string) => match);\r\n};\r\n\r\nconst binToByte = (bin: string): number => parseInt(bin, 2);\r\n\r\nexport const binToBytes = (bin: string) =>\r\n  Uint8Array.from(\r\n    binToBinBytes(bin)\r\n      .reverse()\r\n      .map((binByte) => binToByte(binByte))\r\n  );\r\n","/* import { bytesToHex } from \"./bytes\"; */\r\n\r\n/**\r\n * This implementations is derived from:\r\n * https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js\r\n *\r\n * Copyright 2008 The Closure Library Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nexport const stringToBytes = (text: string): Uint8Array => {\r\n  const out: number[] = [];\r\n  let p: number = 0;\r\n  for (let i = 0; i < text.length; i++) {\r\n    let c: number = text.charCodeAt(i);\r\n    if (c < 128) {\r\n      out[p++] = c;\r\n    } else if (c < 2048) {\r\n      out[p++] = (c >> 6) | 192;\r\n      out[p++] = (c & 63) | 128;\r\n    } else if ((c & 0xfc00) === 0xd800 && i + 1 < text.length && (text.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\r\n      c = ((c & 0x03ff) << 10) + 0x10000 + (text.charCodeAt((i += 1)) & 0x03ff);\r\n      out[p++] = (c >> 18) | 240;\r\n      out[p++] = ((c >> 12) & 63) | 128;\r\n      out[p++] = ((c >> 6) & 63) | 128;\r\n      out[p++] = (c & 63) | 128;\r\n    } else {\r\n      out[p++] = (c >> 12) | 224;\r\n      out[p++] = ((c >> 6) & 63) | 128;\r\n      out[p++] = (c & 63) | 128;\r\n    }\r\n  }\r\n  return new Uint8Array(out);\r\n};\r\n\r\n// export const stringToHex = (text: string): string => bytesToHex(stringToBytes(text));\r\n","import { ParseResult, WizDataList } from \"../model\";\r\nimport { Opcodes } from \"../opcodes\";\r\nimport { Opcode } from \"../opcodes/model/Opcode\";\r\nimport { VM, VM_NETWORK, VM_NETWORK_VERSION } from \"../opcodes/model/VM\";\r\nimport { currentScope } from \"../utils\";\r\nimport { compileJoin } from \"./compileAll\";\r\nimport { parse } from \"./parse\";\r\n\r\nconst initialStackDataList: WizDataList = { inputHexes: [], main: [], alt: [], flow: [true], altFlow: [], isStackFailed: false };\r\n\r\nlet programVersion: VM = { network: VM_NETWORK.BTC, ver: VM_NETWORK_VERSION.SEGWIT };\r\n\r\nexport let stackDataList: WizDataList = initialStackDataList;\r\n\r\nexport let opWordCodes: Opcode[] = [];\r\n\r\nexport const init = (version: VM) => {\r\n  programVersion = version;\r\n\r\n  opWordCodes = new Opcodes(version).data;\r\n};\r\n\r\nexport const parseInput = (input: string): WizDataList => {\r\n  const currentScopeParse: boolean = currentScope(stackDataList);\r\n  const currentScopeParseException: boolean = input === \"OP_IF\" || input === \"OP_NOTIF\" || input === \"OP_ELSE\" || input === \"OP_ENDIF\";\r\n\r\n  const parseResult: ParseResult = parse(input, opWordCodes, stackDataList, currentScopeParse, currentScopeParseException);\r\n\r\n  // add input hexes\r\n  stackDataList = { ...stackDataList, inputHexes: [...stackDataList.inputHexes, parseResult.inputHex], errorMessage: parseResult.errorMessage };\r\n\r\n  // return failed after add input hex\r\n  if (stackDataList.isStackFailed) return { ...stackDataList, isStackFailed: true, errorMessage: \"Stack failed an OP_VERIFY operation.\" };\r\n\r\n  // remove item(s) from main stack\r\n  if (parseResult.main.removeLastSize > 0) {\r\n    stackDataList = { ...stackDataList, main: stackDataList.main.slice(0, stackDataList.main.length - parseResult.main.removeLastSize) };\r\n  }\r\n\r\n  // remove last item from alternate stack\r\n  if (parseResult.alt.removeLastStackData) {\r\n    stackDataList = { ...stackDataList, alt: stackDataList.alt.slice(0, stackDataList.alt.length - 1) };\r\n  }\r\n\r\n  // add item array to main stack\r\n  stackDataList = { ...stackDataList, main: stackDataList.main.concat(parseResult.main.addDataArray) };\r\n\r\n  // add item to alternate stack\r\n  if (parseResult.alt.addData) stackDataList = { ...stackDataList, alt: [...stackDataList.alt, parseResult.alt.addData] };\r\n\r\n  // update flow\r\n  if (parseResult.flow) stackDataList = { ...stackDataList, flow: parseResult.flow };\r\n\r\n  // update alt flow\r\n  if (parseResult.altFlow) stackDataList = { ...stackDataList, altFlow: parseResult.altFlow };\r\n\r\n  // stack failed\r\n  if (parseResult.isStackFailed) {\r\n    stackDataList = { ...stackDataList, isStackFailed: parseResult.isStackFailed, errorMessage: \"Stack failed an OP_VERIFY operation.\" };\r\n  }\r\n\r\n  return stackDataList;\r\n};\r\n\r\nexport const compileScript = () => compileJoin(stackDataList.inputHexes);\r\n\r\nexport const clearStack = () => {\r\n  stackDataList = initialStackDataList;\r\n};\r\n","import { VM, VM_NETWORK, VM_NETWORK_VERSION } from \"./model/VM\";\r\nimport { Opcode } from \"./model/Opcode\";\r\nimport { opcodesBitcoinSegwit } from \"./BITCOIN_SEGWIT\";\r\nimport { opcodesBitcoinTapscript } from \"./BITCOIN_TAPSCRIPT\";\r\nimport { opcodesLiquidSegwit } from \"./LIQUID_SEGWIT\";\r\nimport { opcodesLiquidTapscript } from \"./LIQUID_TAPSCRIPT\";\r\n\r\nconst opcodes = (vm: VM): Opcode[] => {\r\n  if (vm.network === VM_NETWORK.BTC) {\r\n    if (vm.ver === VM_NETWORK_VERSION.SEGWIT) return opcodesBitcoinSegwit;\r\n    // else if(vm.ver === VM_NETWORK_VERSION.TAPSCRIPT)\r\n    return opcodesBitcoinTapscript;\r\n  }\r\n  // else {\r\n  // if (vm.network === VM_NETWORK.LIQUID) {\r\n  if (vm.ver === VM_NETWORK_VERSION.SEGWIT) return opcodesLiquidSegwit;\r\n  // else if(vm.ver === VM_NETWORK_VERSION.TAPSCRIPT)\r\n  return opcodesLiquidTapscript;\r\n  // }\r\n  // }\r\n};\r\n\r\nexport class Opcodes {\r\n  vm: VM;\r\n  data: Opcode[];\r\n\r\n  constructor(vm: VM) {\r\n    this.vm = vm;\r\n    this.data = opcodes(vm);\r\n  }\r\n\r\n  wordData = (word: string): Opcode | undefined => this.data.find((d) => d.word === word);\r\n  wordCode = (word: string): number => {\r\n    const code = this.wordData(word)?.opcode;\r\n    return code === undefined ? -1 : code;\r\n  };\r\n  wordHex = (word: string): string => this.wordData(word)?.hex || \"\";\r\n\r\n  codeData = (code: number): Opcode | undefined => this.data.find((d) => d.opcode === code);\r\n  codeWord = (code: number): string => this.codeData(code)?.word || \"\";\r\n}\r\n","import { Opcode } from \"./model/Opcode\";\r\n\r\nexport const commonOpcodes: Opcode[] = [\r\n  /*\r\n   * Constants\r\n   * * 0 - 96\r\n   */\r\n  {\r\n    word: \"OP_0\",\r\n    opcode: 0,\r\n    hex: \"0x00\",\r\n    output: 0,\r\n    description: \"(empty value)\tAn empty array of bytes is pushed onto the stack. (This is not a no-op: an item is added to the stack.)\",\r\n  }, // Nothing.\t(empty value)\tAn empty array of bytes is pushed onto the stack. (This is not a no-op: an item is added to the stack.)\r\n  {\r\n    word: \"OP_FALSE\",\r\n    opcode: 0,\r\n    hex: \"0x00\",\r\n    output: 0,\r\n    description: \"(empty value)\tAn empty array of bytes is pushed onto the stack. (This is not a no-op: an item is added to the stack.)\",\r\n  }, // Nothing.\t(empty value)\tAn empty array of bytes is pushed onto the stack. (This is not a no-op: an item is added to the stack.)\r\n  // { word: \"N/A\", opcode: 1 - 75, hex: \"0x01-0x4b\", output: 0 }, // (special)\tdata\tThe next opcode bytes is data to be pushed onto the stack\r\n  // { word: \"OP_PUSHDATA1\", opcode: 76, hex: \"0x4c\" }, //\t(special)\tdata\tThe next byte contains the number of bytes to be pushed onto the stack.\r\n  // { word: \"OP_PUSHDATA2\", opcode: 77, hex: \"0x4d\" }, //\t(special)\tdata\tThe next two bytes contain the number of bytes to be pushed onto the stack in little endian order.\r\n  // { word: \"OP_PUSHDATA4\", opcode: 78, hex: \"0x4e\" }, //\t(special)\tdata\tThe next four bytes contain the number of bytes to be pushed onto the stack in little endian order.\r\n  // { word: \"OP_1NEGATE\", opcode: 79, hex: \"0x4f\" }, //\tNothing.\t-1\tThe number -1 is pushed onto the stack.\r\n  { word: \"OP_1\", opcode: 81, hex: \"0x51\", output: 1, description: \"The number 1 is pushed onto the stack.\" }, // Nothing.\t1\tThe number 1 is pushed onto the stack.\r\n  { word: \"OP_TRUE\", opcode: 81, hex: \"0x51\", output: 1, description: \"The number 1 is pushed onto the stack.\" }, // Nothing.\t1\tThe number 1 is pushed onto the stack.\r\n  { word: \"OP_2\", opcode: 82, hex: \"0x52\", output: 2, description: \"The number 2 is pushed onto the stack.\" }, // Nothing.\t2\tThe number 2 is pushed onto the stack.\r\n  { word: \"OP_3\", opcode: 83, hex: \"0x53\", output: 3, description: \"The number 3 is pushed onto the stack.\" }, // Nothing.\t3\tThe number 3 is pushed onto the stack.\r\n  { word: \"OP_4\", opcode: 84, hex: \"0x54\", output: 4, description: \"The number 4 is pushed onto the stack.\" }, // Nothing.\t4\tThe number 4 is pushed onto the stack.\r\n  { word: \"OP_5\", opcode: 85, hex: \"0x55\", output: 5, description: \"The number 5 is pushed onto the stack.\" }, // Nothing.\t5\tThe number 5 is pushed onto the stack.\r\n  { word: \"OP_6\", opcode: 86, hex: \"0x56\", output: 6, description: \"The number 6 is pushed onto the stack.\" }, // Nothing.\t6\tThe number 6 is pushed onto the stack.\r\n  { word: \"OP_7\", opcode: 87, hex: \"0x57\", output: 7, description: \"The number 7 is pushed onto the stack.\" }, // Nothing.\t7\tThe number 7 is pushed onto the stack.\r\n  { word: \"OP_8\", opcode: 88, hex: \"0x58\", output: 8, description: \"The number 8 is pushed onto the stack.\" }, // Nothing.\t8\tThe number 8 is pushed onto the stack.\r\n  { word: \"OP_9\", opcode: 89, hex: \"0x59\", output: 9, description: \"The number 9 is pushed onto the stack.\" }, // Nothing.\t9\tThe number 9 is pushed onto the stack.\r\n  { word: \"OP_10\", opcode: 90, hex: \"0x5a\", output: 10, description: \"The number 10 is pushed onto the stack.\" }, // Nothing.\t10\tThe number 10 is pushed onto the stack.\r\n  { word: \"OP_11\", opcode: 91, hex: \"0x5b\", output: 11, description: \"The number 11 is pushed onto the stack.\" }, // Nothing.\t11\tThe number 11 is pushed onto the stack.\r\n  { word: \"OP_12\", opcode: 92, hex: \"0x5c\", output: 12, description: \"The number 12 is pushed onto the stack.\" }, // Nothing.\t12\tThe number 12 is pushed onto the stack.\r\n  { word: \"OP_13\", opcode: 93, hex: \"0x5d\", output: 13, description: \"The number 13 is pushed onto the stack.\" }, // Nothing.\t13\tThe number 13 is pushed onto the stack.\r\n  { word: \"OP_14\", opcode: 94, hex: \"0x5e\", output: 14, description: \"The number 14 is pushed onto the stack.\" }, // Nothing.\t14\tThe number 14 is pushed onto the stack.\r\n  { word: \"OP_15\", opcode: 95, hex: \"0x5f\", output: 15, description: \"The number 15 is pushed onto the stack.\" }, // Nothing.\t15\tThe number 15 is pushed onto the stack.\r\n  { word: \"OP_16\", opcode: 96, hex: \"0x60\", output: 16, description: \"The number 16 is pushed onto the stack.\" }, // Nothing.\t16\tThe number 16 is pushed onto the stack.\r\n\r\n  /*\r\n   * Flow control\r\n   * * 97 - 106\r\n   */\r\n  { word: \"OP_NOP\", opcode: 97, hex: \"0x61\", description: \"Nothing\tDoes nothing.\" }, //\tNothing\tNothing\tDoes nothing.\r\n  {\r\n    word: \"OP_IF\",\r\n    opcode: 99,\r\n    hex: \"0x63\",\r\n    description: \"if [statements] [else [statements]]* endif\tIf the top stack value is not False, the statements are executed. The top stack value is removed.\",\r\n  }, //\t<expression> if [statements] [else [statements]]* endif\tIf the top stack value is not False, the statements are executed. The top stack value is removed.\r\n  {\r\n    word: \"OP_NOTIF\",\r\n    opcode: 100,\r\n    hex: \"0x64\",\r\n    description: \"notif [statements] [else [statements]]* endif\tIf the top stack value is False, the statements are executed. The top stack value is removed.\",\r\n  }, //\t<expression> notif [statements] [else [statements]]* endif\tIf the top stack value is False, the statements are executed. The top stack value is removed.\r\n  {\r\n    word: \"OP_ELSE\",\r\n    opcode: 103,\r\n    hex: \"0x67\",\r\n    description:\r\n      \" if [statements] [else [statements]]* endif\tIf the preceding OP_IF or OP_NOTIF or OP_ELSE was not executed then these statements are and if the preceding OP_IF or OP_NOTIF or OP_ELSE was executed then these statements are not.\",\r\n  }, //\t<expression> if [statements] [else [statements]]* endif\tIf the preceding OP_IF or OP_NOTIF or OP_ELSE was not executed then these statements are and if the preceding OP_IF or OP_NOTIF or OP_ELSE was executed then these statements are not.\r\n  {\r\n    word: \"OP_ENDIF\",\r\n    opcode: 104,\r\n    hex: \"0x68\",\r\n    description:\r\n      \"if [statements] [else [statements]]* endif\tEnds an if/else block. All blocks must end, or the transaction is invalid. An OP_ENDIF without OP_IF earlier is also invalid.\",\r\n  }, //\t<expression> if [statements] [else [statements]]* endif\tEnds an if/else block. All blocks must end, or the transaction is invalid. An OP_ENDIF without OP_IF earlier is also invalid.\r\n  { word: \"OP_VERIFY\", opcode: 105, hex: \"0x69\", description: \"\tMarks transaction as invalid if top stack value is not true. The top stack value is removed.\" }, //\tTrue / false\tNothing / fail\tMarks transaction as invalid if top stack value is not true. The top stack value is removed.\r\n  { word: \"OP_RETURN\", opcode: 106, hex: \"0x6a\" }, //\tNothing\tfail\tMarks transaction as invalid. Since bitcoin 0.9, a standard way of attaching extra data to transactions is to add a zero-value output with a scriptPubKey consisting of OP_RETURN followed by data. Such outputs are provably unspendable and specially discarded from storage in the UTXO set, reducing their cost to the network. Since 0.12, standard relay rules allow a single output with OP_RETURN, that contains any sequence of push statements (or OP_RESERVED[1]) after the OP_RETURN provided the total scriptPubKey length is at most 83 bytes.\r\n\r\n  /*\r\n   * Stack\r\n   * * 107 - 125\r\n   */\r\n  { word: \"OP_TOALTSTACK\", opcode: 107, hex: \"0x6b\", description: \"Puts the input onto the top of the alt stack. Removes it from the main stack.\" }, //\tx1\t(alt)x1\tPuts the input onto the top of the alt stack. Removes it from the main stack.\r\n  { word: \"OP_FROMALTSTACK\", opcode: 108, hex: \"0x6c\", description: \"Puts the input onto the top of the main stack. Removes it from the alt stack.\" }, //\t(alt)x1\tx1\tPuts the input onto the top of the main stack. Removes it from the alt stack.\r\n  { word: \"OP_2DROP\", opcode: 109, hex: \"0x6d\", description: \"Nothing\tRemoves the top two stack items.\" }, //\tx1 x2\tNothing\tRemoves the top two stack items.\r\n  { word: \"OP_2DUP\", opcode: 110, hex: \"0x6e\", description: \"Duplicates the top two stack items\" }, //\tx1 x2\tx1 x2 x1 x2\tDuplicates the top two stack items.\r\n  { word: \"OP_3DUP\", opcode: 111, hex: \"0x6f\", description: \"Duplicates the top three stack items.\" }, //\tx1 x2 x3\tx1 x2 x3 x1 x2 x3\tDuplicates the top three stack items.\r\n  { word: \"OP_2OVER\", opcode: 112, hex: \"0x70\", description: \"Copies the pair of items two spaces back in the stack to the front.\" }, //\tx1 x2 x3 x4\tx1 x2 x3 x4 x1 x2\tCopies the pair of items two spaces back in the stack to the front.\r\n  { word: \"OP_2ROT\", opcode: 113, hex: \"0x71\", description: \"The fifth and sixth items back are moved to the top of the stack.\" }, //\tx1 x2 x3 x4 x5 x6\tx3 x4 x5 x6 x1 x2\tThe fifth and sixth items back are moved to the top of the stack.\r\n  { word: \"OP_2SWAP\", opcode: 114, hex: \"0x72\", description: \"Swaps the top two pairs of stack.\" }, //\tx1 x2 x3 x4\tx3 x4 x1 x2\tSwaps the top two pairs of stack.\r\n  { word: \"OP_IFDUP\", opcode: 115, hex: \"0x73\", description: \"If the top stack value is not 0, duplicate it.\" }, //\tx\tx / x x\tIf the top stack value is not 0, duplicate it.\r\n  { word: \"OP_DEPTH\", opcode: 116, hex: \"0x74\", description: \"Puts the number of stack items onto the stack.\" }, //\tNothing\t<Stack size>\tPuts the number of stack items onto the stack.\r\n  { word: \"OP_DROP\", opcode: 117, hex: \"0x75\", description: \"Removes the top stack item.\" }, //\tx\tNothing\tRemoves the top stack item.\r\n  { word: \"OP_DUP\", opcode: 118, hex: \"0x76\", description: \"Duplicates the top stack item.\" }, //\tx\tx x\tDuplicates the top stack item.\r\n  { word: \"OP_NIP\", opcode: 119, hex: \"0x77\", description: \"Removes the second-to-top stack item.\" }, //\tx1 x2\tx2\tRemoves the second-to-top stack item.\r\n  { word: \"OP_OVER\", opcode: 120, hex: \"0x78\", description: \"Copies the second-to-top stack item to the top.\" }, //\tx1 x2\tx1 x2 x1\tCopies the second-to-top stack item to the top.\r\n  { word: \"OP_PICK\", opcode: 121, hex: \"0x79\", description: \"The item n back in the stack is copied to the top.\" }, //\txn ... x2 x1 x0 <n>\txn ... x2 x1 x0 xn\tThe item n back in the stack is copied to the top.\r\n  { word: \"OP_ROLL\", opcode: 122, hex: \"0x7a\", description: \"The item n back in the stack is moved to the top.\" }, //\txn ... x2 x1 x0 <n>\t... x2 x1 x0 xn\tThe item n back in the stack is moved to the top.\r\n  { word: \"OP_ROT\", opcode: 123, hex: \"0x7b\", description: \"The 3rd item down the stack is moved to the top.\" }, //\tx1 x2 x3\tx2 x3 x1\tThe 3rd item down the stack is moved to the top.\r\n  { word: \"OP_SWAP\", opcode: 124, hex: \"0x7c\", description: \"The top two items on the stack are swapped.\" }, //\tx1 x2\tx2 x1\tThe top two items on the stack are swapped.\r\n  { word: \"OP_TUCK\", opcode: 125, hex: \"0x7d\", description: \"The item at the top of the stack is copied and inserted before the second-to-top item.\" }, //\tx1 x2\tx2 x1 x2\tThe item at the top of the stack is copied and inserted before the second-to-top item.\r\n\r\n  /*\r\n   * Splice\r\n   * 126 - 130\r\n   */\r\n  // { word: \"OP_CAT\", opcode: 126, hex: \"0x7e\", description: \"Concatenates two strings.\" }, //\tx1 x2\tout\tConcatenates two strings. disabled.\r\n  // { word: \"OP_SUBSTR\", opcode: 127, hex: \"0x7f\", description: \"Returns a section of a string.\" }, //\tin begin size\tout\tReturns a section of a string. disabled.\r\n  // { word: \"OP_LEFT\", opcode: 128, hex: \"0x80\", description: \"Keeps only characters left of the specified point in a string.\" }, //\tin size\tout\tKeeps only characters left of the specified point in a string. disabled.\r\n  // { word: \"OP_RIGHT\", opcode: 129, hex: \"0x81\", description: \"Keeps only characters right of the specified point in a string\" }, //\tin size\tout\tKeeps only characters right of the specified point in a string. disabled.\r\n  { word: \"OP_SIZE\", opcode: 130, hex: \"0x82\", description: \"Pushes the string length of the top element of the stack (without popping it).\" }, //\tin\tin size\tPushes the string length of the top element of the stack (without popping it).\r\n\r\n  /*\r\n   * Bitwise logic\r\n   * 131 - 136\r\n   */\r\n  // { word: \"OP_INVERT\", opcode: 131, hex: \"0x83\", description: \"Flips all of the bits in the input.\" }, //\tin\tout\tFlips all of the bits in the input. disabled.\r\n  // { word: \"OP_AND\", opcode: 132, hex: \"0x84\", description: \"Boolean and between each bit in the inputs.\" }, //\tx1 x2\tout\tBoolean and between each bit in the inputs. disabled.\r\n  // { word: \"OP_OR\", opcode: 133, hex: \"0x85\", description: \"Boolean or between each bit in the inputs.\" }, //\tx1 x2\tout\tBoolean or between each bit in the inputs. disabled.\r\n  // { word: \"OP_XOR\", opcode: 134, hex: \"0x86\", description: \"Boolean exclusive or between each bit in the inputs.\" }, //\tx1 x2\tout\tBoolean exclusive or between each bit in the inputs. disabled.\r\n  // { word: \"OP_EQUAL\", opcode: 135, hex: \"0x87\", description: \"Returns 1 if the inputs are exactly equal, 0 otherwise.\" }, //\tx1 x2\tTrue / false\tReturns 1 if the inputs are exactly equal, 0 otherwise.\r\n  { word: \"OP_EQUALVERIFY\", opcode: 136, hex: \"0x88\", description: \"Same as OP_EQUAL, but runs OP_VERIFY afterward.\" }, //\tx1 x2\tNothing / fail\tSame as OP_EQUAL, but runs OP_VERIFY afterward.\r\n\r\n  /*\r\n   * Arithmetic\r\n   * 139 - 165\r\n   */\r\n  { word: \"OP_1ADD\", opcode: 139, hex: \"0x8b\", description: \"1 is added to the input.\" }, //\tin\tout\t1 is added to the input.\r\n  { word: \"OP_1SUB\", opcode: 140, hex: \"0x8c\", description: \"1 is subtracted from the input.\" }, //\tin\tout\t1 is subtracted from the input.\r\n  // { word: \"OP_2MUL\", opcode: 141, hex: \"0x8d\" }, //\tin\tout\tThe input is multiplied by 2. disabled.\r\n  // { word: \"OP_2DIV\", opcode: 142, hex: \"0x8e\" }, //\tin\tout\tThe input is divided by 2. disabled.\r\n  { word: \"OP_NEGATE\", opcode: 143, hex: \"0x8f\", description: \"The sign of the input is flipped.\" }, //\tin\tout\tThe sign of the input is flipped.\r\n  { word: \"OP_ABS\", opcode: 144, hex: \"0x90\", description: \"The input is made positive.\" }, //\tin\tout\tThe input is made positive.\r\n  { word: \"OP_NOT\", opcode: 145, hex: \"0x91\", description: \"If the input is 0 or 1, it is flipped. Otherwise the output will be 0.\" }, //\tin\tout\tIf the input is 0 or 1, it is flipped. Otherwise the output will be 0.\r\n  { word: \"OP_0NOTEQUAL\", opcode: 146, hex: \"0x92\", description: \"Returns 0 if the input is 0. 1 otherwise.\" }, //\tin\tout\tReturns 0 if the input is 0. 1 otherwise.\r\n  { word: \"OP_ADD\", opcode: 147, hex: \"0x93\", description: \"a is added to b.\" }, //\ta b\tout\ta is added to b.\r\n  { word: \"OP_SUB\", opcode: 148, hex: \"0x94\", description: \"b is subtracted from a.\" }, //\ta b\tout\tb is subtracted from a.\r\n  // { word: \"OP_MUL\", opcode: 149, hex: \"0x95\" }, //\ta b\tout\ta is multiplied by b. disabled.\r\n  // { word: \"OP_DIV\", opcode: 150, hex: \"0x96\" }, //\ta b\tout\ta is divided by b. disabled.\r\n  // { word: \"OP_MOD\", opcode: 151, hex: \"0x97\" }, //\ta b\tout\tReturns the remainder after dividing a by b. disabled.\r\n  // { word: \"OP_LSHIFT\", opcode: 152, hex: \"0x98\", description: \"Shifts a left b bits, preserving sign.\" }, //\ta b\tout\tShifts a left b bits, preserving sign. disabled.\r\n  // { word: \"OP_RSHIFT\", opcode: 153, hex: \"0x99\", description: \"Shifts a right b bits, preserving sign.\" }, //\ta b\tout\tShifts a right b bits, preserving sign. disabled.\r\n  { word: \"OP_BOOLAND\", opcode: 154, hex: \"0x9a\", description: \"\tIf both a and b are not 0, the output is 1. Otherwise 0.\" }, //\ta b\tout\tIf both a and b are not 0, the output is 1. Otherwise 0.\r\n  { word: \"OP_BOOLOR\", opcode: 155, hex: \"0x9b\", description: \"If a or b is not 0, the output is 1. Otherwise 0.\" }, //\ta b\tout\tIf a or b is not 0, the output is 1. Otherwise 0.\r\n  { word: \"OP_NUMEQUAL\", opcode: 156, hex: \"0x9c\", description: \"Returns 1 if the numbers are equal, 0 otherwise.\" }, //\ta b\tout\tReturns 1 if the numbers are equal, 0 otherwise.\r\n  { word: \"OP_NUMEQUALVERIFY\", opcode: 157, hex: \"0x9d\", description: \"Same as OP_NUMEQUAL, but runs OP_VERIFY afterward.\" }, //\ta b\tNothing / fail\tSame as OP_NUMEQUAL, but runs OP_VERIFY afterward.\r\n  { word: \"OP_NUMNOTEQUAL\", opcode: 158, hex: \"0x9e\", description: \"Returns 1 if the numbers are not equal, 0 otherwise.\" }, //\ta b\tout\tReturns 1 if the numbers are not equal, 0 otherwise.\r\n  { word: \"OP_LESSTHAN\", opcode: 159, hex: \"0x9f\", description: \"Returns 1 if a is less than b, 0 otherwise.\" }, //\ta b\tout\tReturns 1 if a is less than b, 0 otherwise.\r\n  { word: \"OP_GREATERTHAN\", opcode: 160, hex: \"0xa0\", description: \"Returns 1 if a is greater than b, 0 otherwise.\" }, //\ta b\tout\tReturns 1 if a is greater than b, 0 otherwise.\r\n  { word: \"OP_LESSTHANOREQUAL\", opcode: 161, hex: \"0xa1\", description: \"Returns 1 if a is less than or equal to b, 0 otherwise.\" }, //\ta b\tout\tReturns 1 if a is less than or equal to b, 0 otherwise.\r\n  { word: \"OP_GREATERTHANOREQUAL\", opcode: 162, hex: \"0xa2\", description: \"\tReturns 1 if a is greater than or equal to b, 0 otherwise.\" }, //\ta b\tout\tReturns 1 if a is greater than or equal to b, 0 otherwise.\r\n  { word: \"OP_MIN\", opcode: 163, hex: \"0xa3\", description: \"Returns the smaller of a and b.\" }, //\ta b\tout\tReturns the smaller of a and b.\r\n  { word: \"OP_MAX\", opcode: 164, hex: \"0xa4\", description: \"Returns the larger of a and b.\" }, //\ta b\tout\tReturns the larger of a and b.\r\n  { word: \"OP_WITHIN\", opcode: 165, hex: \"0xa5\", description: \"Returns 1 if x is within the specified range (left-inclusive), 0 otherwise.\" }, //\tx min max\tout\tReturns 1 if x is within the specified range (left-inclusive), 0 otherwise.\r\n\r\n  /*\r\n   * Crypto\r\n   * 166 - 175\r\n   */\r\n  { word: \"OP_RIPEMD160\", opcode: 166, hex: \"0xa6\", description: \"The input is hashed using RIPEMD-160.\" }, //\tin\thash\tThe input is hashed using RIPEMD-160.\r\n  { word: \"OP_SHA1\", opcode: 167, hex: \"0xa7\", description: \"The input is hashed using SHA-1.\" }, //\tin\thash\tThe input is hashed using SHA-1.\r\n  { word: \"OP_SHA256\", opcode: 168, hex: \"0xa8\", description: \"The input is hashed using SHA-256.\" }, //\tin\thash\tThe input is hashed using SHA-256.\r\n  { word: \"OP_HASH160\", opcode: 169, hex: \"0xa9\", description: \"The input is hashed twice: first with SHA-256 and then with RIPEMD-160.\" }, //\tin\thash\tThe input is hashed twice: first with SHA-256 and then with RIPEMD-160.\r\n  { word: \"OP_HASH256\", opcode: 170, hex: \"0xaa\", description: \"The input is hashed two times with SHA-256.\" }, //\tin\thash\tThe input is hashed two times with SHA-256.\r\n  // { word: \"OP_CODESEPARATOR\", opcode: 171, hex: \"0xab\" }, //\tNothing\tNothing\tAll of the signature checking words will only match signatures to the data after the most recently-executed OP_CODESEPARATOR.\r\n  { word: \"OP_CHECKSIG\", opcode: 172, hex: \"0xac\" }, //\tsig pubkey\tTrue / false\tThe entire transaction's outputs, inputs, and script (from the most recently-executed OP_CODESEPARATOR to the end) are hashed. The signature used by OP_CHECKSIG must be a valid signature for this hash and public key. If it is, 1 is returned, 0 otherwise.\r\n  { word: \"OP_CHECKSIGVERIFY\", opcode: 173, hex: \"0xad\" }, //\tsig pubkey\tNothing / fail\tSame as OP_CHECKSIG, but OP_VERIFY is executed afterward.\r\n  // { word: \"OP_CHECKMULTISIG\", opcode: 174, hex: \"0xae\" }, //\tx sig1 sig2 ... <number of signatures> pub1 pub2 <number of public keys>\tTrue / False\tCompares the first signature against each public key until it finds an ECDSA match. Starting with the subsequent public key, it compares the second signature against each remaining public key until it finds an ECDSA match. The process is repeated until all signatures have been checked or not enough public keys remain to produce a successful result. All signatures need to match a public key. Because public keys are not checked again if they fail any signature comparison, signatures must be placed in the scriptSig using the same order as their corresponding public keys were placed in the scriptPubKey or redeemScript. If all signatures are valid, 1 is returned, 0 otherwise. Due to a bug, one extra unused value is removed from the stack.\r\n  // { word: \"OP_CHECKMULTISIGVERIFY\", opcode: 175, hex: \"0xaf\" }, //\tx sig1 sig2 ... <number of signatures> pub1 pub2 ... <number of public keys>\tNothing / fail\tSame as OP_CHECKMULTISIG, but OP_VERIFY is executed afterward.\r\n\r\n  /*\r\n   * Locktime\r\n   * 177 - 178\r\n   */\r\n  // (previously OP_NOP2)\r\n  { word: \"OP_CHECKLOCKTIMEVERIFY\", opcode: 177, hex: \"0xb1\" }, //\tx\tx / fail\tMarks transaction as invalid if the top stack item is greater than the transaction's nLockTime field, otherwise script evaluation continues as though an OP_NOP was executed. Transaction is also invalid if 1. the stack is empty; or 2. the top stack item is negative; or 3. the top stack item is greater than or equal to 500000000 while the transaction's nLockTime field is less than 500000000, or vice versa; or 4. the input's nSequence field is equal to 0xffffffff. The precise semantics are described in BIP 0065.\r\n  // (previously OP_NOP3)\r\n  { word: \"OP_CHECKSEQUENCEVERIFY\", opcode: 178, hex: \"0xb2\" }, //\tx\tx / fail\tMarks transaction as invalid if the relative lock time of the input (enforced by BIP 0068 with nSequence) is not equal to or longer than the value of the top stack item. The precise semantics are described in BIP 0112.\r\n\r\n  /*\r\n   * Reserved words\r\n   * 80, 98, 101, 102, 137, 138, 176, 179-185\r\n   */\r\n  // { word: \"OP_RESERVED\", opcode: 80, hex: \"0x50\" }, //\tTransaction is invalid unless occuring in an unexecuted OP_IF branch\r\n  // { word: \"OP_VER\", opcode: 98, hex: \"0x62\" }, //\tTransaction is invalid unless occuring in an unexecuted OP_IF branch\r\n  // { word: \"OP_VERIF\", opcode: 101, hex: \"0x65\" }, //\tTransaction is invalid even when occuring in an unexecuted OP_IF branch\r\n  // { word: \"OP_VERNOTIF\", opcode: 102, hex: \"0x66\" }, //\tTransaction is invalid even when occuring in an unexecuted OP_IF branch\r\n  // { word: \"OP_RESERVED1\", opcode: 137, hex: \"0x89\" }, //\tTransaction is invalid unless occuring in an unexecuted OP_IF branch\r\n  // { word: \"OP_RESERVED2\", opcode: 138, hex: \"0x8a\" }, //\tTransaction is invalid unless occuring in an unexecuted OP_IF branch\r\n  // { word: \"OP_NOP1\", opcode: 176, hex: \"0xb0\" }, //\tThe word is ignored. Does not mark transaction as invalid.\r\n  // { word: \"OP_NOP4\", opcode: 179, hex: \"0xb3\" }, //\tThe word is ignored. Does not mark transaction as invalid.\r\n  // { word: \"OP_NOP5\", opcode: 180, hex: \"0xb4\" }, //\tThe word is ignored. Does not mark transaction as invalid.\r\n  // { word: \"OP_NOP6\", opcode: 181, hex: \"0xb5\" }, //\tThe word is ignored. Does not mark transaction as invalid.\r\n  // { word: \"OP_NOP7\", opcode: 182, hex: \"0xb6\" }, //\tThe word is ignored. Does not mark transaction as invalid.\r\n  // { word: \"OP_NOP8\", opcode: 183, hex: \"0xb7\" }, //\tThe word is ignored. Does not mark transaction as invalid.\r\n  // { word: \"OP_NOP9\", opcode: 184, hex: \"0xb8\" }, //\tThe word is ignored. Does not mark transaction as invalid.\r\n  // { word: \"OP_NOP10\", opcode: 185, hex: \"0xb9\" }, //\tThe word is ignored. Does not mark transaction as invalid.\r\n\r\n  /*\r\n   * Pseudo-words\r\n   * 253 - 255\r\n   */\r\n  // { word: \"OP_PUBKEYHASH\", opcode: 253, hex: \"0xfd\" }, //\tRepresents a public key hashed with OP_HASH160.\r\n  // { word: \"OP_PUBKEY\", opcode: 254, hex: \"0xfe\" }, //\tRepresents a public key compatible with OP_CHECKSIG.\r\n  // { word: \"OP_INVALIDOPCODE\", opcode: 255, hex: \"0xff\" }, //\tMatches any opcode that is not yet assigned.\r\n];\r\n","import { Opcode } from \"./model/Opcode\";\r\nimport { opcodesBitcoinTapscript } from \"./BITCOIN_TAPSCRIPT\";\r\nimport { opcodesLiquidSegwit } from \"./LIQUID_SEGWIT\";\r\n\r\nexport const opcodesLiquidTapscript: Opcode[] = [...opcodesBitcoinTapscript, ...opcodesLiquidSegwit];\r\n","import WizData from \"../convertion\";\r\nimport { ParseResult, ParseResultData, WizDataList } from \"../model\";\r\nimport { Opcode } from \"../opcodes/model/Opcode\";\r\nimport { cropTwo, opcodeToWord, opWordToHex } from \"../utils\";\r\nimport { compileData } from \"./compileAll\";\r\nimport { opFuncs } from \"./opFuncs\";\r\nimport { parseFinalInput } from \"./parseFinalInput\";\r\n\r\nexport const parse = (input: string, opWordCodes: Opcode[], stackDataList: WizDataList, currentScopeParse: boolean, currentScopeParseException: boolean): ParseResult => {\r\n  let emptyParseResultData: ParseResultData = {\r\n    main: { addDataArray: [], removeLastSize: 0 },\r\n    alt: { removeLastStackData: false },\r\n  };\r\n\r\n  let inputHex: string = \"\";\r\n\r\n  try {\r\n    // Data\r\n    if (input.startsWith(\"<\") && input.endsWith(\">\")) {\r\n      const finalInput = input.substr(1, input.length - 2);\r\n      const addStackData: WizData = parseFinalInput(finalInput);\r\n      inputHex = compileData(addStackData.hex);\r\n\r\n      if (currentScopeParse)\r\n        return {\r\n          inputHex,\r\n          main: { addDataArray: [addStackData], removeLastSize: 0 },\r\n          alt: { removeLastStackData: false },\r\n        };\r\n      else return { ...emptyParseResultData, inputHex };\r\n    }\r\n\r\n    // OP Word or OP Code\r\n    if (input.startsWith(\"OP_\") || !isNaN(input as any)) {\r\n      // OP Word\r\n      let word = input;\r\n      // Op Code\r\n      if (!isNaN(input as any)) {\r\n        word = opcodeToWord(Number(input), opWordCodes);\r\n        if (word === \"\") throw \"Unknown OP code number\";\r\n      }\r\n\r\n      inputHex = cropTwo(opWordToHex(word, opWordCodes));\r\n\r\n      if (inputHex === \"\") throw \"Unknown OP code\";\r\n\r\n      if (currentScopeParse || currentScopeParseException) emptyParseResultData = opFuncs(word, stackDataList, opWordCodes);\r\n      return { ...emptyParseResultData, inputHex };\r\n    }\r\n  } catch (ex) {\r\n    return { inputHex, errorMessage: ex, main: { addDataArray: [], removeLastSize: 0 }, alt: { removeLastStackData: false } };\r\n  }\r\n\r\n  return { inputHex, errorMessage: \"it is not a valid input script\", main: { addDataArray: [], removeLastSize: 0 }, alt: { removeLastStackData: false } };\r\n};\r\n","import WizData from \"../convertion\";\r\nimport * as arithmetics from \"../core/arithmetics\";\r\nimport { ParseResultData, WizDataList } from \"../model\";\r\nimport { Opcode } from \"../opcodes/model/Opcode\";\r\n\r\nexport const opFuncs = (word: string, stackDataList: WizDataList, opCodes: Opcode[]): ParseResultData => {\r\n  const mainStackDataArray: WizData[] = stackDataList.main;\r\n  const mainStackDataArrayLength = mainStackDataArray.length;\r\n\r\n  /*\r\n   * Constants\r\n   * * 0 - 96\r\n   */\r\n  if (\r\n    word === \"OP_0\" ||\r\n    word === \"OP_FALSE\" ||\r\n    word === \"OP_1\" ||\r\n    word === \"OP_TRUE\" ||\r\n    word === \"OP_2\" ||\r\n    word === \"OP_3\" ||\r\n    word === \"OP_4\" ||\r\n    word === \"OP_5\" ||\r\n    word === \"OP_6\" ||\r\n    word === \"OP_7\" ||\r\n    word === \"OP_8\" ||\r\n    word === \"OP_9\" ||\r\n    word === \"OP_10\" ||\r\n    word === \"OP_11\" ||\r\n    word === \"OP_12\" ||\r\n    word === \"OP_13\" ||\r\n    word === \"OP_14\" ||\r\n    word === \"OP_15\" ||\r\n    word === \"OP_16\"\r\n  ) {\r\n    const currentOpCode = opCodes.find((oc) => oc.word === word);\r\n    const addDataArray: WizData[] = [WizData.fromNumber(currentOpCode?.output || 0)];\r\n\r\n    const removeLastSize: number = 0;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  /*\r\n   * Flow control\r\n   * * 97 - 106\r\n   */\r\n  // if (word === \"OP_NOP\") {\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray: [], removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_IF\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_IF Error: stack data array must include min 1 data!\";\r\n\r\n  //   const flows = OP_IF(stackDataList);\r\n  //   const removeLastSize: number = currentScope(stackDataList) ? 1 : 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray: [], removeLastSize }, alt, flow: flows.flow, altFlow: flows.altFlow };\r\n  // }\r\n  // if (word === \"OP_NOTIF\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_NOTIF Error: stack data array must include min 1 data!\";\r\n\r\n  //   const flows = OP_NOTIF(stackDataList);\r\n  //   const removeLastSize: number = currentScope(stackDataList) ? 1 : 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray: [], removeLastSize }, alt, flow: flows.flow, altFlow: flows.altFlow };\r\n  // }\r\n  // if (word === \"OP_ELSE\") {\r\n  //   if (stackDataList.flow.length === 1) throw \"OP_ELSE Error: Encountered an OP_ELSE outside of an OP_IF ... OP_ENDIF block.!\";\r\n\r\n  //   const flows = OP_ELSE(stackDataList);\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray: [], removeLastSize }, alt, flow: flows.flow, altFlow: flows.altFlow };\r\n  // }\r\n  // if (word === \"OP_ENDIF\") {\r\n  //   if (stackDataList.flow.length === 1) throw \"OP_ENDIF Error: Encountered an OP_ENDIF which is not following a matching OP_IF.!\";\r\n\r\n  //   const flows = OP_ENDIF(stackDataList);\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray: [], removeLastSize }, alt, flow: flows.flow, altFlow: flows.altFlow };\r\n  // }\r\n  // if (word === \"OP_VERIFY\") {\r\n  //   if (mainStackDataArray.length < 1) throw \"OP_VERIFY Error:  stack data array must include min 1 data!!\";\r\n\r\n  //   const isVerify = OP_VERIFY(mainStackDataArray[mainStackDataArray.length - 1]);\r\n\r\n  //   if (isVerify) {\r\n  //     const addDataArray: StackData[] = [];\r\n  //     const removeLastSize: number = 1;\r\n  //     const alt = { removeLastStackData: false };\r\n\r\n  //     return { main: { addDataArray, removeLastSize }, alt };\r\n  //   } else {\r\n  //     return { main: { addDataArray: [], removeLastSize: 0 }, alt: { removeLastStackData: false }, isStackFailed: true };\r\n  //   }\r\n  // }\r\n  // if (word === \"OP_RETURN\") {\r\n  //   throw \"Program called on OP_RETURN operation\";\r\n  // }\r\n\r\n  /*\r\n   * Stack\r\n   * * 107 - 125\r\n   */\r\n  // if (word === \"OP_TOALTSTACK\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_TOALTSTACK Error: stack data array must include min 1 data!\";\r\n  //   const addDataArray: StackData[] = stacks.OP_TOALTSTACK();\r\n  //   const removeLastSize: number = 1;\r\n  //   const alt = { addData: mainStackDataArray[mainStackDataArrayLength - 1], removeLastStackData: false };\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_FROMALTSTACK\") {\r\n  //   const altStackDataArrayLength = stackDataList.alt.length;\r\n  //   if (altStackDataArrayLength < 1) throw \"OP_FROMALTSTACK Error: tried to read from an empty alternate stack.\";\r\n  //   const addDataArray: StackData[] = stacks.OP_FROMALTSTACK(stackDataList.alt[stackDataList.alt.length - 1]);\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: true };\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_2DROP\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_2DROP Error: stack data array must include min 2 data!\";\r\n  //   const addDataArray: StackData[] = stacks.OP_2DROP();\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_2DUP\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_2DUP Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = stacks.OP_2DUP(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_3DUP\") {\r\n  //   if (mainStackDataArrayLength < 3) throw \"OP_3DUP Error: stack data array must include min 3 data!\";\r\n\r\n  //   const addDataArray: StackData[] = stacks.OP_3DUP(\r\n  //     mainStackDataArray[mainStackDataArrayLength - 3],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 2],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 1]\r\n  //   );\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_2OVER\") {\r\n  //   if (mainStackDataArrayLength < 4) throw \"OP_2OVER Error: stack data array must include min 4 data!\";\r\n  //   const addDataArray: StackData[] = stacks.OP_2OVER(mainStackDataArray[mainStackDataArrayLength - 4], mainStackDataArray[mainStackDataArrayLength - 3]);\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_2SWAP\") {\r\n  //   if (mainStackDataArrayLength < 4) throw \"OP_2SWAP Error: stack data array must include min 4 data!\";\r\n  //   const addDataArray: StackData[] = stacks.OP_2SWAP(\r\n  //     mainStackDataArray[mainStackDataArrayLength - 1],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 2],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 3],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 4]\r\n  //   );\r\n  //   const removeLastSize: number = 4;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_IFDUP\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_IFDUP Error: stack data array must include min 1 data!\";\r\n\r\n  //   const addDataArray: StackData[] = stacks.OP_IFDUP(mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_DEPTH\") {\r\n  //   const addDataArray: StackData[] = stacks.OP_DEPTH(mainStackDataArrayLength);\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n\r\n  // if (word === \"OP_DROP\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_DROP Error: stack data array must include min 1 data!\";\r\n\r\n  //   const addDataArray: StackData[] = stacks.OP_DROP();\r\n  //   const removeLastSize: number = 1;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_DUP\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_DUP Error: stack data array must include min 1 data!\";\r\n  //   const addDataArray: StackData[] = stacks.OP_DUP(mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_NIP\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_NIP Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = stacks.OP_NIP(mainStackDataArray[mainStackDataArrayLength - 1], mainStackDataArray[mainStackDataArrayLength - 2]);\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_OVER\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_OVER Error: stack data array must include min 2 data!\";\r\n  //   const addDataArray: StackData[] = stacks.OP_OVER(mainStackDataArray[mainStackDataArrayLength - 2]);\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_SWAP\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_SWAP Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = stacks.OP_SWAP(mainStackDataArray[mainStackDataArrayLength - 1], mainStackDataArray[mainStackDataArrayLength - 2]);\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_2ROT\") {\r\n  //   if (mainStackDataArrayLength < 6) throw \"OP_2ROT Error: stack data array must include min 6 data!\";\r\n\r\n  //   const addDataArray: StackData[] = stacks.OP_2ROT(\r\n  //     mainStackDataArray[mainStackDataArrayLength - 6],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 5],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 4],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 3],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 2],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 1]\r\n  //   );\r\n\r\n  //   const removeLastSize: number = 6;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_ROT\") {\r\n  //   if (mainStackDataArrayLength < 3) throw \"OP_ROT Error: stack data array must include min 3 data!\";\r\n\r\n  //   const addDataArray: StackData[] = stacks.OP_ROT(\r\n  //     mainStackDataArray[mainStackDataArrayLength - 3],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 2],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 1]\r\n  //   );\r\n\r\n  //   const removeLastSize: number = 3;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_PICK\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_PICK Error: stack data array must include min 2 data!\";\r\n\r\n  //   let stackIndex: number | undefined = mainStackDataArray[mainStackDataArrayLength - 1].numberValue;\r\n  //   let willChangedStackDataArray: StackData[] = [...mainStackDataArray];\r\n  //   willChangedStackDataArray.pop();\r\n\r\n  //   if (stackIndex !== undefined) {\r\n  //     if (stackIndex >= willChangedStackDataArray.length) throw \"OP_PICK Error: stack index cant be equal and greater than stack array length\";\r\n  //   } else {\r\n  //     throw \"OP_PICK Error: stack index must be a number\";\r\n  //   }\r\n\r\n  //   const addDataArray: StackData[] = stacks.OP_PICK(willChangedStackDataArray, stackIndex);\r\n\r\n  //   const removeLastSize: number = mainStackDataArray.length;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_ROLL\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_ROLL Error: stack data array must include min 2 data!\";\r\n\r\n  //   let stackIndex: number | undefined = mainStackDataArray[mainStackDataArrayLength - 1].numberValue;\r\n  //   let willChangedStackDataArray: StackData[] = [...mainStackDataArray];\r\n  //   willChangedStackDataArray.pop();\r\n\r\n  //   if (stackIndex !== undefined) {\r\n  //     if (stackIndex >= willChangedStackDataArray.length) throw \"OP_ROLL Error: stack index cant be equal and greater than stack array length\";\r\n  //   } else {\r\n  //     throw \"OP_ROLL Error: stack index must be a number\";\r\n  //   }\r\n\r\n  //   const addDataArray: StackData[] = stacks.OP_ROLL(willChangedStackDataArray, stackIndex);\r\n\r\n  //   const removeLastSize: number = mainStackDataArray.length;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_TUCK\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_TUCK Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = stacks.OP_TUCK(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n\r\n  /*\r\n   * Splice\r\n   * 126 - 130\r\n   */\r\n  // if (word === \"OP_CAT\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_CAT Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = splices.OP_CAT(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_SUBSTR\") {\r\n  //   if (mainStackDataArrayLength < 3) throw \"OP_SUBSTR Error: stack data array must include min 3 data!\";\r\n\r\n  //   const addDataArray: StackData[] = splices.OP_SUBSTR(\r\n  //     mainStackDataArray[mainStackDataArrayLength - 3],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 2],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 1]\r\n  //   );\r\n  //   const removeLastSize: number = 3;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_RIGHT\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_RIGHT Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = splices.OP_RIGHT(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_LEFT\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_LEFT Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = splices.OP_LEFT(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_SIZE\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_SIZE Error: stack data array must include min 1 data!\";\r\n  //   const addDataArray: StackData[] = splices.OP_SIZE(mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_SUBSTR_LAZY\") {\r\n  //   if (mainStackDataArrayLength < 3) throw \"OP_SUBSTR_LAZY Error: stack data array must include min 3 data!\";\r\n\r\n  //   const addDataArray: StackData[] = splices.OP_SUBSTR_LAZY(\r\n  //     mainStackDataArray[mainStackDataArrayLength - 3],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 2],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 1]\r\n  //   );\r\n  //   const removeLastSize: number = 3;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n\r\n  /*\r\n   * Bitwise logic\r\n   * 131 - 136\r\n   */\r\n\r\n  // if (word === \"OP_INVERT\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_INVERT Error: stack data array must include min 1 data!\";\r\n\r\n  //   const addDataArray: StackData[] = OP_INVERT(mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_AND\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_AND Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = OP_AND(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_OR\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_OR Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = OP_OR(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_XOR\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_XOR Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = OP_XOR(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_EQUAL\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_EQUAL Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = OP_EQUAL(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_EQUALVERIFY\") {\r\n  //   if (mainStackDataArray.length < 2) throw \"OP_EQUALVERIFY Error:  stack data array must include min 2 data!!\";\r\n\r\n  //   const isVerify = OP_EQUALVERIFY(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n\r\n  //   if (isVerify) {\r\n  //     const addDataArray: StackData[] = [];\r\n  //     const removeLastSize: number = 2;\r\n  //     const alt = { removeLastStackData: false };\r\n\r\n  //     return { main: { addDataArray, removeLastSize }, alt };\r\n  //   } else {\r\n  //     return { main: { addDataArray: [], removeLastSize: 0 }, alt: { removeLastStackData: false }, isStackFailed: true };\r\n  //   }\r\n  // }\r\n\r\n  /*\r\n   * Arithmetic\r\n   * 139 - 165\r\n   */\r\n  if (word === \"OP_1ADD\") {\r\n    if (mainStackDataArrayLength < 1) throw \"OP_1ADD Error: stack data array must include min 1 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.add1(mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 1;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_1SUB\") {\r\n    if (mainStackDataArrayLength < 1) throw \"OP_1SUB Error: stack data array must include min 1 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.sub1(mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 1;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_NEGATE\") {\r\n    if (mainStackDataArrayLength < 1) throw \"OP_NEGATE Error: stack data array must include min 1 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.negate(mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 1;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_ABS\") {\r\n    if (mainStackDataArrayLength < 1) throw \"OP_ABS Error: stack data array must include min 1 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.abs(mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 1;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_NOT\") {\r\n    if (mainStackDataArrayLength < 1) throw \"OP_NOT Error: stack data array must include min 1 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.not(mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 1;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_0NOTEQUAL\") {\r\n    if (mainStackDataArrayLength < 1) throw \"OP_0NOTEQUAL Error: stack data array must include min 1 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.notEqual0(mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 1;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_ADD\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_ADD Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.add(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_SUB\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_SUB Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.sub(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_MUL\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_MUL Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.mul(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_DIV\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_DIV Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.div(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_LSHIFT\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_LSHIFT Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.lshift(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_RSHIFT\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_RSHIFT Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.rshift(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_BOOLAND\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_BOOLAND Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.boolAnd(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_BOOLOR\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_BOOLOR Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.boolOr(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_NUMEQUAL\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_NUMEQUAL Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.numEqual(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_NUMEQUALVERIFY\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_NUMEQUALVERIFY Error: stack data array must include min 2 data!\";\r\n\r\n    const isVerifed: boolean = arithmetics.numEqualVerify(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]).number === 1;\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray: [], removeLastSize }, alt, isStackFailed: !isVerifed };\r\n  }\r\n\r\n  if (word === \"OP_NUMNOTEQUAL\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_NUMNOTEQUAL Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.numNotEqual(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_LESSTHAN\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_LESSTHAN Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.lessThan(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_GREATERTHAN\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_GREATERTHAN Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.graterThan(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_LESSTHANOREQUAL\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_LESSTHANOREQUAL Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.lessThanOrEqual(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_GREATERTHANOREQUAL\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_GREATERTHANOREQUAL Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.graterThanOrEqual(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_MIN\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_MIN Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.min(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_MAX\") {\r\n    if (mainStackDataArrayLength < 2) throw \"OP_MAX Error: stack data array must include min 2 data!\";\r\n\r\n    const addDataArray: WizData[] = [arithmetics.max(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1])];\r\n    const removeLastSize: number = 2;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  if (word === \"OP_WITHIN\") {\r\n    if (mainStackDataArrayLength < 3) throw \"OP_WITHIN Error: stack data array must include min 3 data!\";\r\n\r\n    const addDataArray: WizData[] = [\r\n      arithmetics.withIn(\r\n        mainStackDataArray[mainStackDataArrayLength - 3], // x\r\n        mainStackDataArray[mainStackDataArrayLength - 2], // min\r\n        mainStackDataArray[mainStackDataArrayLength - 1] // max\r\n      ),\r\n    ];\r\n\r\n    const removeLastSize: number = 3;\r\n    const alt = { removeLastStackData: false };\r\n\r\n    return { main: { addDataArray, removeLastSize }, alt };\r\n  }\r\n\r\n  /*\r\n   * Crypto\r\n   * 166 - 175\r\n   */\r\n  // if (word === \"OP_SHA1\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_SHA1 Error: stack data array must include min 1 data!\";\r\n\r\n  //   const addDataArray: StackData[] = cryptos.OP_SHA1(mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 1;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_SHA256\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_SHA256 Error: stack data array must include min 1 data!\";\r\n\r\n  //   const addDataArray: StackData[] = cryptos.OP_SHA256(mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 1;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_RIPEMD160\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_RIPEMD160 Error: stack data array must include min 1 data!\";\r\n\r\n  //   const addDataArray: StackData[] = cryptos.OP_RIPEMD160(mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 1;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_HASH160\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_HASH160 Error: stack data array must include min 1 data!\";\r\n\r\n  //   const addDataArray: StackData[] = cryptos.OP_HASH160(mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 1;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_HASH256\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_HASH256 Error: stack data array must include min 1 data!\";\r\n\r\n  //   const addDataArray: StackData[] = cryptos.OP_HASH256(mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 1;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_CHECKSIG\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_CHECKSIG Error: stack data array must include min 2 data!\";\r\n\r\n  //   const addDataArray: StackData[] = cryptos.OP_CHECKSIG(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_CHECKSIGVERIFY\") {\r\n  //   if (mainStackDataArrayLength < 2) throw \"OP_CHECKSIGVERIFY Error: stack data array must include min 2 data!\";\r\n\r\n  //   let isStackFailed: boolean = false;\r\n\r\n  //   const addDataArray: StackData[] = cryptos.OP_CHECKSIG(mainStackDataArray[mainStackDataArrayLength - 2], mainStackDataArray[mainStackDataArrayLength - 1]);\r\n  //   const removeLastSize: number = 2;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   if (addDataArray[0].numberValue === 0) isStackFailed = true;\r\n\r\n  //   return { main: { addDataArray: [], removeLastSize }, alt, isStackFailed };\r\n  // }\r\n  // if (word === \"OP_CHECKSIGFROMSTACK\") {\r\n  //   if (mainStackDataArrayLength < 3) throw \"OP_CHECKSIGFROMSTACK Error: stack data array must include min 3 data!\";\r\n\r\n  //   const addDataArray: StackData[] = cryptos.OP_CHECKSIGFROMSTACK(\r\n  //     mainStackDataArray[mainStackDataArrayLength - 3],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 2],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 1]\r\n  //   );\r\n  //   const removeLastSize: number = 3;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt };\r\n  // }\r\n  // if (word === \"OP_CHECKSIGFROMSTACKVERIFY\") {\r\n  //   if (mainStackDataArrayLength < 3) throw \"OP_CHECKSIGFROMSTACKVERIFY Error: stack data array must include min 3 data!\";\r\n  //   let isStackFailed: boolean = false;\r\n\r\n  //   const addDataArray: StackData[] = cryptos.OP_CHECKSIGFROMSTACK(\r\n  //     mainStackDataArray[mainStackDataArrayLength - 3],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 2],\r\n  //     mainStackDataArray[mainStackDataArrayLength - 1]\r\n  //   );\r\n\r\n  //   if (addDataArray[0].numberValue === 0) isStackFailed = true;\r\n\r\n  //   const removeLastSize: number = 3;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray: [], removeLastSize }, alt, isStackFailed };\r\n  // }\r\n\r\n  /*\r\n   * Locktime\r\n   * 177 - 178\r\n   */\r\n  // if (word === \"OP_CHECKLOCKTIMEVERIFY\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_CHECKLOCKTIMEVERIFY Error: stack data array must include min 1 data!\";\r\n  //   let isStackFailed: boolean = false;\r\n\r\n  //   const addDataArray: StackData[] = locktime.OP_CHECKLOCKTIMEVERIFY(mainStackDataArray[mainStackDataArrayLength - 1]);\r\n\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt, isStackFailed };\r\n  // }\r\n\r\n  // if (word === \"OP_CHECKSEQUENCEVERIFY\") {\r\n  //   if (mainStackDataArrayLength < 1) throw \"OP_CHECKSEQUENCEVERIFY Error: stack data array must include min 1 data!\";\r\n  //   let isStackFailed: boolean = false;\r\n\r\n  //   const addDataArray: StackData[] = locktime.OP_CHECKSEQUENCEVERIFY(mainStackDataArray[mainStackDataArrayLength - 1]);\r\n\r\n  //   const removeLastSize: number = 0;\r\n  //   const alt = { removeLastStackData: false };\r\n\r\n  //   return { main: { addDataArray, removeLastSize }, alt, isStackFailed };\r\n  // }\r\n\r\n  /*\r\n   * Not implemented yet\r\n   */\r\n  throw \"Known OP word but not implemented yet!\";\r\n};\r\n","import WizData from \"../convertion\";\r\n\r\nexport const add1 = (wizData: WizData): WizData => {\r\n  if (wizData.number !== undefined) {\r\n    const numberValue: number = wizData.number + 1;\r\n    return WizData.fromNumber(numberValue);\r\n  }\r\n\r\n  throw \"Error: this operation requires 1 valid number wizData\";\r\n};\r\n\r\nexport const sub1 = (wizData: WizData): WizData => {\r\n  if (wizData.number !== undefined) {\r\n    const numberValue: number = wizData.number - 1;\r\n    return WizData.fromNumber(numberValue);\r\n  }\r\n\r\n  throw \"Error: this operation requires 1 valid number wizData\";\r\n};\r\n\r\nexport const negate = (wizData: WizData): WizData => {\r\n  if (wizData.number !== undefined) {\r\n    const negateValue: number = wizData.number * -1;\r\n    return WizData.fromNumber(negateValue);\r\n  }\r\n\r\n  throw \"Error: this operation requires 1 valid number wizData\";\r\n};\r\n\r\nexport const abs = (wizData: WizData): WizData => {\r\n  if (wizData.number !== undefined) {\r\n    const absValue: number = Math.abs(wizData.number);\r\n    return WizData.fromNumber(absValue);\r\n  }\r\n\r\n  throw \"Error: this operation requires 1 valid number wizData\";\r\n};\r\n\r\nexport const not = (wizData: WizData): WizData => {\r\n  if (wizData.number !== undefined) {\r\n    const isfalse: boolean = !wizData.number;\r\n\r\n    return WizData.fromNumber(isfalse ? 1 : 0);\r\n  }\r\n\r\n  throw \"Error: this operation requires 1 valid number wizData\";\r\n};\r\n\r\nexport const notEqual0 = (wizData: WizData): WizData => {\r\n  if (wizData.number !== undefined) {\r\n    const isfalse: boolean = !wizData.number;\r\n\r\n    return WizData.fromNumber(isfalse ? 0 : 1);\r\n  }\r\n\r\n  throw \"Error: this operation requires 1 valid number wizData\";\r\n};\r\n\r\nexport const add = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    const addedValue: number = wizData.number + wizData2.number;\r\n    return WizData.fromNumber(addedValue);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const sub = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    const subValue: number = wizData.number - wizData2.number;\r\n    return WizData.fromNumber(subValue);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const mul = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    const mulValue: number = wizData.number * wizData2.number;\r\n    return WizData.fromNumber(mulValue);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const div = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    if (wizData2.number === 0) throw \"Error: dividing can't be eqaul 0.\";\r\n\r\n    let divValue: number = wizData.number / wizData2.number;\r\n\r\n    divValue = divValue > 0 ? Math.floor(divValue) : Math.ceil(divValue);\r\n    return WizData.fromNumber(divValue);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const lshift = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    const lShiftValue: number = wizData.number << wizData2.number;\r\n    return WizData.fromNumber(lShiftValue);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const rshift = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    const rShiftValue: number = wizData.number >> wizData2.number;\r\n    return WizData.fromNumber(rShiftValue);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const boolAnd = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    if (wizData.number === 0 || wizData2.number === 0)\r\n      return WizData.fromNumber(0);\r\n    return WizData.fromNumber(1);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const boolOr = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    if (wizData.number === 0 && wizData2.number === 0)\r\n      return WizData.fromNumber(0);\r\n    return WizData.fromNumber(1);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const numEqual = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    return WizData.fromNumber(wizData.number === wizData2.number ? 1 : 0);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const numEqualVerify = (\r\n  wizData: WizData,\r\n  wizData2: WizData\r\n): WizData => {\r\n  return numEqual(wizData, wizData2);\r\n};\r\n\r\nexport const numNotEqual = (wizData: WizData, wizData2: WizData): WizData => {\r\n  const equal = numEqual(wizData, wizData2).number === 1;\r\n  return WizData.fromNumber(equal ? 0 : 1);\r\n};\r\n\r\nexport const lessThan = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    return WizData.fromNumber(wizData.number < wizData2.number ? 1 : 0);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const graterThan = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    return WizData.fromNumber(wizData.number > wizData2.number ? 1 : 0);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const lessThanOrEqual = (\r\n  wizData: WizData,\r\n  wizData2: WizData\r\n): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    return WizData.fromNumber(wizData.number <= wizData2.number ? 1 : 0);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const graterThanOrEqual = (\r\n  wizData: WizData,\r\n  wizData2: WizData\r\n): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    return WizData.fromNumber(wizData.number >= wizData2.number ? 1 : 0);\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const min = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    if (wizData.number >= wizData2.number) return wizData2;\r\n\r\n    if (wizData2.number > wizData.number) return wizData;\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const max = (wizData: WizData, wizData2: WizData): WizData => {\r\n  if (wizData.number !== undefined && wizData2.number !== undefined) {\r\n    if (wizData.number >= wizData2.number) return wizData;\r\n\r\n    if (wizData2.number > wizData.number) return wizData2;\r\n  }\r\n\r\n  throw \"Error: this operation requires 2 valid number wizData\";\r\n};\r\n\r\nexport const withIn = (\r\n  wizData: WizData,\r\n  wizData2: WizData,\r\n  wizData3: WizData\r\n): WizData => {\r\n  const currentNumber = wizData.number;\r\n  const minValue = wizData2.number;\r\n  const maxValue = wizData3.number;\r\n\r\n  if (\r\n    currentNumber !== undefined &&\r\n    minValue !== undefined &&\r\n    maxValue !== undefined\r\n  ) {\r\n    if (currentNumber >= minValue && currentNumber <= maxValue)\r\n      return WizData.fromNumber(1);\r\n\r\n    return WizData.fromNumber(0);\r\n  }\r\n\r\n  throw \"Error: this operation requires 3 valid number wizData\";\r\n};\r\n","import WizData from \"../convertion\";\r\nimport { cropTwo, EMOJI_REGEX } from \"../utils\";\r\n\r\nexport const parseFinalInput = (input: string): WizData => {\r\n  // 0x1245\r\n  // :D\r\n  // \"hello\"\r\n  // OP_...\r\n  // 12\r\n\r\n  // HEX DATA INPUT\r\n  if (input.startsWith(\"0x\")) {\r\n    const cropedInput = cropTwo(input);\r\n    return WizData.fromHex(cropedInput);\r\n  }\r\n\r\n  // EMOJI INPUT\r\n  if ((input.startsWith('\"') && input.endsWith('\"')) || (input.startsWith(\"'\") && input.endsWith(\"'\"))) {\r\n    if (input.match(EMOJI_REGEX)) {\r\n      const formattedInput = input.substr(1, input.length - 2);\r\n      return WizData.fromHex(\"f09f8c8e\");\r\n    }\r\n  }\r\n\r\n  // STRING INPUT\r\n  if ((input.startsWith('\"') && input.endsWith('\"')) || (input.startsWith(\"'\") && input.endsWith(\"'\"))) {\r\n    const formattedInput = input.substr(1, input.length - 2);\r\n    return WizData.fromText(formattedInput);\r\n  }\r\n\r\n  // OP_DATA INPUT\r\n  // if (input.startsWith(\"OP_\")) {\r\n  //   const hex = opWordToHex(input);\r\n  //   if (hex === \"\") throw \"ParseFinalInput Error: it is not a valid op word!\";\r\n  //   if (hex === \"0x00\") return { byteValue: \"0x00\", input: \"0x00\", byteValueDisplay: \"0\" };\r\n\r\n  //   return stackHex(hex);\r\n  // }\r\n\r\n  // NUMBER INPUT\r\n  if (!isNaN(input as any)) {\r\n    return WizData.fromNumber(Number(input));\r\n  }\r\n\r\n  throw \"ParseFinalInput Error: it is not a valid final input string!\";\r\n};\r\n"],"sourceRoot":""}